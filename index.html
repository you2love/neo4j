<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo4j 图数据库学习教程 2026</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="lib/all.min.css">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <i class="fas fa-project-diagram"></i>
                <span>Neo4j 教程</span>
            </div>
            <div class="nav-menu">
                <a href="#basics" class="nav-link">基础知识</a>
                <a href="#algorithms" class="nav-link">图算法</a>
                <a href="#cypher" class="nav-link">Cypher 查询</a>
                <a href="#modeling" class="nav-link">数据建模</a>
                <a href="#features" class="nav-link">新特性</a>
                <a href="#aiml" class="nav-link">AI/ML 集成</a>
                <a href="#drivers" class="nav-link">编程语言</a>
                <a href="#examples" class="nav-link">实战示例</a>
            </div>
        </div>
    </nav>

    <main class="main-content">
        <section id="basics" class="section">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-cube"></i>
                    Neo4j 基础知识
                </h2>
                <div class="section-content">
                    <div class="card">
                        <div class="card-icon">
                            <i class="fas fa-database"></i>
                        </div>
                        <h3>什么是图数据库</h3>
                        <p>图数据库是一种以图结构（节点和边）来存储、查询和管理数据的数据库系统。它能够高效地处理复杂的数据关系，特别适合社交网络、推荐系统、欺诈检测等场景。</p>
                    </div>
                    <div class="card">
                        <div class="card-icon">
                            <i class="fas fa-cubes"></i>
                        </div>
                        <h3>核心概念</h3>
                        <ul>
                            <li><strong>节点（Node）</strong>：代表实体，如人、公司、产品等</li>
                            <li><strong>关系（Relationship）</strong>：代表节点之间的连接</li>
                            <li><strong>属性（Property）</strong>：存储在节点和关系上的数据</li>
                            <li><strong>标签（Label）</strong>：对节点进行分类的标记</li>
                        </ul>
                    </div>
                    <div class="card">
                        <div class="card-icon">
                            <i class="fas fa-chart-line"></i>
                        </div>
                        <h3>为什么选择 Neo4j</h3>
                        <ul>
                            <li>原生图存储，性能卓越</li>
                            <li>支持 ACID 事务</li>
                            <li>强大的 Cypher 查询语言</li>
                            <li>丰富的生态系统和工具支持</li>
                            <li>企业级安全和扩展性</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section id="algorithms" class="section section-alt">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-share-alt"></i>
                    常见图算法介绍
                </h2>
                <div class="section-content">
                    <div class="tutorial-block">
                        <h3>1. 中心性算法 (Centrality Algorithms)</h3>
                        <p>中心性算法用于识别图中最重要的节点，常用于社交网络分析、关键人物识别等场景。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>PageRank</h4>
                                <p>基于网页链接关系的算法，通过迭代计算节点的权重。Google创始人Page和Brin提出，用于网页排名。</p>
                                <ul>
                                    <li><strong>应用场景</strong>：网页排名、社交网络影响力度量、关键节点识别</li>
                                    <li><strong>原理</strong>：一个节点的重要性取决于指向它的其他节点的数量和质量</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Degree Centrality</h4>
                                <p>度中心性是最简单的中心性指标，衡量节点的直接连接数量。</p>
                                <ul>
                                    <li><strong>应用场景</strong>：识别社交网络中的活跃用户、发现高度连接的设备</li>
                                    <li><strong>特点</strong>：计算简单，但不能区分节点影响力的质量</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Betweenness Centrality</h4>
                                <p>介数中心性衡量节点在最短路径上出现的频率，反映节点的"桥梁"作用。</p>
                                <ul>
                                    <li><strong>应用场景</strong>：交通网络关键节点识别、信息传播瓶颈发现</li>
                                    <li><strong>特点</strong>：能发现连接不同社群的桥接节点</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Closeness Centrality</h4>
                                <p>接近中心性衡量节点到其他所有节点的平均距离的倒数。</p>
                                <ul>
                                    <li><strong>应用场景</strong>：紧急设施选址、病毒传播源识别</li>
                                    <li><strong>特点</strong>：值越大表示节点到其他节点的平均距离越短</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// PageRank 示例 - 识别最有影响力的节点
CALL gds.pageRank.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC
LIMIT 10

// Degree Centrality 示例 - 找出连接数最多的节点
CALL gds.degree.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC

// Betweenness Centrality 示例 - 识别关键桥梁节点
CALL gds.betweenness.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC
LIMIT 10</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>2. 社区发现算法 (Community Detection)</h3>
                        <p>社区发现算法用于识别图中紧密连接的节点群组，是图分析的核心任务之一。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>Louvain 算法</h4>
                                <p>基于模块度优化的启发式算法，是目前最流行的社区发现算法之一。</p>
                                <ul>
                                    <li><strong>应用场景</strong>：社交网络分析、生物信息学中的蛋白质网络分析</li>
                                    <li><strong>特点</strong>：速度快、可处理大规模图、支持加权图</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Label Propagation</h4>
                                <p>标签传播算法是一种简单快速的社区发现方法。</p>
                                <ul>
                                    <li><strong>应用场景</strong>：大规模网络的快速社区划分</li>
                                    <li><strong>特点</strong>：计算复杂度低，结果可能不稳定</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Connected Components</h4>
                                <p>连通分量算法找出图中相互连通的节点集合。</p>
                                <ul>
                                    <li><strong>应用场景</strong>：网络分区分析、孤立网络识别</li>
                                    <li><strong>特点</strong>：分为强连通分量和弱连通分量</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Triangle Counting</h4>
                                <p>三角形计数算法计算图中三角形的数量及其分布。</p>
                                <ul>
                                    <li><strong>应用场景</strong>：网络密度分析、社区紧密程度评估</li>
                                    <li><strong>特点</strong>：三角形密集的区域通常代表紧密的社区</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// Louvain 社区发现
CALL gds.louvain.stream('myGraph')
YIELD nodeId, communityId
RETURN communityId, 
       count(*) AS community_size,
       collect(gds.util.asNode(nodeId).name) AS members
ORDER BY community_size DESC

// 弱连通分量分析
CALL gds.wcc.stream('myGraph')
YIELD nodeId, componentId
RETURN componentId, count(*) AS size
ORDER BY size DESC

// 三角形计数（带过滤）
CALL gds.triangleCount.stream('myGraph')
YIELD nodeId, triangleCount
RETURN gds.util.asNode(nodeId).name AS name, triangleCount
ORDER BY triangleCount DESC
LIMIT 10</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>3. 路径查找算法 (Path Finding)</h3>
                        <p>路径查找算法用于计算图中节点之间的最短路径或最优路径。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>Shortest Path</h4>
                                <p>最短路径算法计算两个节点之间的最短路径，支持加权图。</p>
                                <ul>
                                    <li><strong>Dijkstra算法</strong>：适合非负权重的最短路径</li>
                                    <li><strong>A*算法</strong>：启发式搜索，效率更高</li>
                                    <li><strong>应用</strong>：导航系统、网络路由、资源分配</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>All Shortest Paths</h4>
                                <p>计算所有节点对之间的最短路径。</p>
                                <ul>
                                    <li><strong>应用</strong>：网络可靠性分析、系统容错设计</li>
                                    <li><strong>特点</strong>：计算复杂度较高，适合中小规模图</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Minimum Spanning Tree</h4>
                                <p>最小生成树算法连接所有节点且总权重最小。</p>
                                <ul>
                                    <li><strong>应用</strong>：网络设计、聚类分析、电路设计</li>
                                    <li><strong>常见算法</strong>：Prim算法、Kruskal算法</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Random Walk</h4>
                                <p>随机游走算法模拟随机漫步过程，用于采样和嵌入。</p>
                                <ul>
                                    <li><strong>应用</strong>：节点嵌入采样、推荐系统、社区检测</li>
                                    <li><strong>特点</strong>：为Node2Vec等嵌入方法提供基础</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 最短路径 (Dijkstra)
MATCH (start:Person {name: '张三'}), (end:Person {name: '李四'})
CALL gds.shortestPath.dijkstra.stream('myGraph', {
    sourceNode: start,
    targetNode: end,
    relationshipWeightProperty: 'distance'
})
YIELD nodeIds, path
RETURN [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path

// A* 算法 (带启发式)
MATCH (start:Location {name: 'A'}), (end:Location {name: 'Z'})
CALL gds.shortestPath.astar.stream('myGraph', {
    sourceNode: start,
    targetNode: end,
    relationshipWeightProperty: 'distance',
    heuristicProperty: 'heuristic'
})
YIELD nodeIds, costs
RETURN [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path

// 所有节点对最短路径
CALL gds.allShortestPaths.stream('myGraph', {
    relationshipWeightProperty: 'distance'
})
YIELD sourceNodeName, targetNodeName, distance
WHERE sourceNodeName < targetNodeName
RETURN sourceNodeName, targetNodeName, distance
ORDER BY distance DESC
LIMIT 10</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>4. 链接预测算法 (Link Prediction)</h3>
                        <p>链接预测算法用于预测图中未来可能形成的关系，广泛应用于推荐系统和欺诈检测。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>Common Neighbors</h4>
                                <p>共同邻居算法：两个节点的共同邻居越多，它们越可能相连。</p>
                                <ul>
                                    <li><strong>公式</strong>：|N(u) ∩ N(v)|</li>
                                    <li><strong>应用</strong>：好友推荐、商品推荐</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Adamic-Adar Index</h4>
                                <p>AA指数：考虑邻居的稀有程度，稀有邻居贡献更大。</p>
                                <ul>
                                    <li><strong>公式</strong>：Σ z∈N(u)∩N(v) 1/log(deg(z))</li>
                                    <li><strong>应用</strong>：社交网络链接预测</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Resource Allocation</h4>
                                <p>资源分配指数：模拟资源从节点u通过共同邻居传递到节点v的过程。</p>
                                <ul>
                                    <li><strong>公式</strong>：Σ z∈N(u)∩N(v) 1/deg(z)</li>
                                    <li><strong>应用</strong>：复杂网络链接预测</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Preferential Attachment</h4>
                                <p>优先连接：节点的度越高，越容易获得新连接。</p>
                                <ul>
                                    <li><strong>公式</strong>：deg(u) × deg(v)</li>
                                    <li><strong>应用</strong>：新节点接入预测、网络演化</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// Common Neighbors 链接预测
MATCH (p1:Person {name: '张三'})
CALL gds.linkPrediction.commonNeighbors.stream('myGraph', {
    sourceNode: p1
})
YIELD node2, score
RETURN node2.name AS candidate, score
ORDER BY score DESC
LIMIT 10

// Adamic-Adar 链接预测
MATCH (p1:Person {name: '张三'})
CALL gds.linkPrediction.adamicAdar.stream('myGraph', {
    sourceNode: p1
})
YIELD node2, score
RETURN node2.name AS candidate, score
ORDER BY score DESC
LIMIT 10

// 资源分配指数
MATCH (p1:Person {name: '张三'})
CALL gds.linkPrediction.resourceAllocation.stream('myGraph', {
    sourceNode: p1
})
YIELD node2, score
RETURN node2.name AS candidate, score
ORDER BY score DESC
LIMIT 10

// 优先连接
MATCH (p1:Person {name: '张三'})
CALL gds.linkPrediction.preferentialAttachment.stream('myGraph', {
    sourceNode: p1
})
YIELD node2, score
RETURN node2.name AS candidate, score
ORDER BY score DESC
LIMIT 10</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>5. 节点嵌入算法 (Node Embedding)</h3>
                        <p>节点嵌入算法将图中的节点映射到低维向量空间，便于机器学习模型处理。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>Node2Vec</h4>
                                <p>结合深度优先和广度优先游走的节点嵌入方法。</p>
                                <ul>
                                    <li><strong>参数</strong>：p (return), q (in-out)</li>
                                    <li><strong>应用</strong>：节点分类、链接预测、聚类</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>FastRP (Fast Random Projection)</h4>
                                <p>基于随机投影的快速节点嵌入算法。</p>
                                <ul>
                                    <li><strong>特点</strong>：速度快、可扩展性好</li>
                                    <li><strong>应用</strong>：大规模图嵌入、特征工程</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>GraphSAGE</h4>
                                <p>基于图神经网络的归纳式节点嵌入方法。</p>
                                <ul>
                                    <li><strong>特点</strong>：支持未见过的节点泛化</li>
                                    <li><strong>应用</strong>：动态图、归纳学习</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>HashGNN</h4>
                                <p>基于哈希的图神经网络嵌入方法。</p>
                                <ul>
                                    <li><strong>特点</strong>：高效、可解释性强</li>
                                    <li><strong>应用</strong>：快速嵌入、大规模图</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// Node2Vec 嵌入
CALL gds.node2vec.stream('myGraph', {
    embeddingDimension: 128,
    walkLength: 80,
    walksPerNode: 10,
    returnFactor: 1.0,
    inOutFactor: 1.0
})
YIELD nodeId, embedding
RETURN gds.util.asNode(nodeId).name AS name, embedding[0..5] AS preview

// FastRP 嵌入
CALL gds.fastRP.write('myGraph', {
    embeddingDimension: 256,
    relationshipWeightProperty: 'weight',
    writeProperty: 'embedding'
})

// GraphSAGE 训练
CALL gds.graphSage.train('myGraph', {
    modelName: 'myModel',
    featureProperties: ['age', 'income'],
    embeddingDimension: 64,
    aggregator: 'mean',
    epochs: 10
})

// 使用训练好的模型预测
CALL gds.graphSage.predict.stream('myGraph', {
    modelName: 'myModel'
})
YIELD nodeId, predictedLabel
RETURN gds.util.asNode(nodeId).name AS name, predictedLabel</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>6. 相似度算法 (Similarity Algorithms)</h3>
                        <p>相似度算法用于衡量节点或图之间的相似程度。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>Jaccard Similarity</h4>
                                <p>Jaccard相似度：两个集合的交集与并集的比值。</p>
                                <ul>
                                    <li><strong>公式</strong>：|A ∩ B| / |A ∪ B|</li>
                                    <li><strong>应用</strong>：用户行为相似度、文本相似度</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Cosine Similarity</h4>
                                <p>余弦相似度：向量夹角的余弦值。</p>
                                <ul>
                                    <li><strong>公式</strong>：A·B / (|A|×|B|)</li>
                                    <li><strong>应用</strong>：基于嵌入向量的相似度计算</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Euclidean Distance</h4>
                                <p>欧几里得距离：两点之间的直线距离。</p>
                                <ul>
                                    <li><strong>公式</strong>：√Σ(Ai-Bi)²</li>
                                    <li><strong>应用</strong>：聚类分析、异常检测</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Pearson Correlation</h4>
                                <p>皮尔逊相关系数：衡量两个向量的线性相关程度。</p>
                                <ul>
                                    <li><strong>范围</strong>：-1到1</li>
                                    <li><strong>应用</strong>：特征相似度、行为分析</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// Jaccard 相似度
MATCH (p1:Person {name: '张三'})
CALL gds.nodeSimilarity.jaccard.stream('myGraph', {
    sourceNode: p1
})
YIELD node2, similarity
RETURN node2.name AS similar_person, similarity
ORDER BY similarity DESC
LIMIT 10

// Cosine 相似度 (基于嵌入向量)
MATCH (p1:Person {name: '张三'}), (p2:Person)
WHERE p1 <> p2
WITH p1, p2, gds.similarity.cosine(p1.embedding, p2.embedding) AS similarity
RETURN p2.name, similarity
ORDER BY similarity DESC
LIMIT 10

// Euclidean 距离
MATCH (p1:Person {name: '张三'}), (p2:Person)
WHERE p1 <> p2
WITH p1, p2, gds.similarity.euclideanDistance(p1.embedding, p2.embedding) AS distance
RETURN p2.name, distance
ORDER BY distance ASC
LIMIT 10

// 余弦相似度 (节点属性)
MATCH (p1:Person {name: '张三'}), (p2:Person)
WHERE p1 <> p2
WITH p1, p2, gds.similarity.cosine([p1.age, p1.income], [p2.age, p2.income]) AS similarity
RETURN p2.name, similarity
ORDER BY similarity DESC
LIMIT 10</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>7. 节点分类算法 (Node Classification)</h3>
                        <p>节点分类算法用于预测节点的标签或类别。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>GraphSAGE Classification</h4>
                                <p>基于GraphSAGE的归纳式节点分类。</p>
                                <ul>
                                    <li><strong>输入</strong>：节点特征、图结构</li>
                                    <li><strong>输出</strong>：节点类别标签</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>Node2Vec + 传统ML</h4>
                                <p>先用Node2Vec生成嵌入，再用传统机器学习分类。</p>
                                <ul>
                                    <li><strong>优点</strong>：灵活、可解释性强</li>
                                    <li><strong>缺点</strong>：需要标注数据</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>半监督学习</h4>
                                <p>利用少量标注数据和大量未标注数据进行学习。</p>
                                <ul>
                                    <li><strong>应用</strong>：欺诈检测、异常识别</li>
                                    <li><strong>优点</strong>：减少标注成本</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>多标签分类</h4>
                                <p>一个节点可以同时属于多个类别。</p>
                                <ul>
                                    <li><strong>应用</strong>：用户兴趣分类、文档标注</li>
                                    <li><strong>特点</strong>：更贴近真实场景</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// GraphSAGE 节点分类训练
CALL gds.graphSage.train('myGraph', {
    modelName: 'nodeClassifier',
    featureProperties: ['age', 'income', 'activityScore'],
    labelProperty: 'category',
    embeddingDimension: 128,
    aggregator: 'mean',
    epochs: 20,
    batchSize: 64,
    learningRate: 0.01
})

// 使用模型进行预测
CALL gds.graphSage.predict.stream('myGraph', {
    modelName: 'nodeClassifier'
})
YIELD nodeId, predictedCategory, probability
RETURN gds.util.asNode(nodeId).name AS name, 
       predictedCategory AS prediction,
       probability
ORDER BY probability DESC

// 使用投影图进行分类（避免污染原图）
CALL gds.graph.project(
    'projectionGraph',
    ['Person'],
    ['FRIEND_OF', 'WORKS_WITH'],
    {
        nodeProperties: ['age', 'income', 'activityScore'],
        relationshipProperties: {weight: 'weight'}
    }
)

CALL gds.graphSage.train('projectionGraph', {
    modelName: 'classifierOnProjection',
    featureProperties: ['age', 'income', 'activityScore'],
    labelProperty: 'category',
    epochs: 10
})

CALL gds.graph.drop('projectionGraph')</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>8. 图神经网络 (Graph Neural Networks)</h3>
                        <p>图神经网络是深度学习在图结构数据上的扩展，能够学习复杂的图模式。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>GCN (Graph Convolutional Network)</h4>
                                <p>图卷积网络，通过卷积操作聚合邻居信息。</p>
                                <ul>
                                    <li><strong>层数</strong>：通常2-3层</li>
                                    <li><strong>应用</strong>：节点分类、图分类</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>GAT (Graph Attention Network)</h4>
                                <p>图注意力网络，使用注意力机制聚合邻居信息。</p>
                                <ul>
                                    <li><strong>特点</strong>：可学习邻居权重</li>
                                    <li><strong>应用</strong>：推荐系统、分子性质预测</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>GraphSAGE</h4>
                                <p>归纳式图神经网络，支持未见节点的泛化。</p>
                                <ul>
                                    <li><strong>特点</strong>：可扩展、支持采样</li>
                                    <li><strong>应用</strong>：动态图、大规模图</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>链接预测 GNN</h4>
                                <p>专门用于链接预测的图神经网络模型。</p>
                                <ul>
                                    <li><strong>应用</strong>：社交网络好友推荐、知识图谱补全</li>
                                    <li><strong>特点</strong>：端到端学习</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// GCN 用于节点分类
CALL gds.alpha.gcn.train('myGraph', {
    modelName: 'gcnClassifier',
    featureProperties: ['feature1', 'feature2', 'feature3'],
    labelProperty: 'label',
    hiddenDim: 64,
    epochs: 100,
    learningRate: 0.01
})

// GAT 节点分类
CALL gds.alpha.gat.train('myGraph', {
    modelName: 'gatClassifier',
    featureProperties: ['feature1', 'feature2'],
    labelProperty: 'label',
    hiddenDim: 64,
    heads: 8,
    epochs: 100
})

// GNN 链接预测
CALL gds.alpha.ml.linkPrediction.train('myGraph', {
    modelName: 'gnnLinkPredictor',
    featureProperties: ['embedding'],
    hiddenDim: 32,
    epochs: 50
})

// 使用 GNN 模型预测新链接
CALL gds.alpha.ml.linkPrediction.predict('myGraph', {
    modelName: 'gnnLinkPredictor',
    topK: 10
})
YIELD node1, node2, probability
RETURN node1.name, node2.name, probability
ORDER BY probability DESC</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>9. 实体解析算法 (Entity Resolution)</h3>
                        <p>实体解析用于识别不同数据源中代表同一实体的节点。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>相似性连接</h4>
                                <p>基于属性相似度识别可能匹配的实体对。</p>
                                <ul>
                                    <li><strong>应用</strong>：数据去重、记录链接</li>
                                    <li><strong>方法</strong>：Jaro-Winkler、编辑距离</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>基于图的匹配</h4>
                                <p>利用节点之间的关系进行实体匹配。</p>
                                <ul>
                                    <li><strong>应用</strong>：跨数据库实体对齐</li>
                                    <li><strong>优点</strong>：考虑上下文信息</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>传递闭包</h4>
                                <p>通过传递性推断实体的等价关系。</p>
                                <ul>
                                    <li><strong>应用</strong>：实体合并、社区发现</li>
                                    <li><strong>注意</strong>：避免错误传递</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>冲突检测</h4>
                                <p>检测合并后数据的属性冲突。</p>
                                <ul>
                                    <li><strong>应用</strong>：数据清洗、质量检查</li>
                                    <li><strong>方法</strong>：投票、最值选择</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 相似性连接示例
MATCH (p1:Person), (p2:Person)
WHERE p1 <> p2 
  AND p1.lastName = p2.lastName
  AND size(p1.firstName) > 3
  AND size(p2.firstName) > 3
WITH p1, p2,
     gds.similarity.jaccard(p1.alias, p2.alias) AS nameSimilarity
WHERE nameSimilarity > 0.7
RETURN p1.name AS entity1, p2.name AS entity2, nameSimilarity
ORDER BY nameSimilarity DESC

// 基于图的实体解析
MATCH (p1:Person {id: '12345'})
MATCH (p2:Person {id: '67890'})
// 检查是否有共同的朋友
WITH p1, p2,
     [(p1)-[:FRIEND_OF]->(f)-[:FRIEND_OF]->(p2) | f] AS mutualFriends
WHERE size(mutualFriends) > 2
RETURN p1, p2, mutualFriends

// 实体合并（创建等价关系）
MATCH (p1:Person {source: 'systemA'}), (p2:Person {source: 'systemB'})
WHERE p1.name = p2.name AND p1.birthDate = p2.birthDate
MERGE (p1)-[:SAME_AS]->(p2)

// 查询合并后的实体
MATCH (p:Person)-[:SAME_AS]->(other:Person)
RETURN collect(DISTINCT p.id) AS merged_ids, p.name AS name</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>10. 时序图算法 (Temporal Graph Algorithms)</h3>
                        <p>时序图算法专门处理带有时间信息的图结构。</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>时序最短路径</h4>
                                <p>考虑时间约束的最短路径计算。</p>
                                <ul>
                                    <li><strong>应用</strong>：航班预订、时间敏感路由</li>
                                    <li><strong>约束</strong>：必须按时间顺序到达</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>时序社区发现</h4>
                                <p>追踪社区随时间的演变。</p>
                                <ul>
                                    <li><strong>应用</strong>：社交动态分析、趋势发现</li>
                                    <li><strong>方法</strong>：快照比较、演化追踪</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>时序链接预测</h4>
                                <p>预测未来可能出现的关系。</p>
                                <ul>
                                    <li><strong>应用</strong>：用户行为预测、趋势分析</li>
                                    <li><strong>特点</strong>：考虑时间衰减</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h4>影响传播</h4>
                                <p>追踪信息或影响在网络中的传播。</p>
                                <ul>
                                    <li><strong>应用</strong>：病毒传播建模、营销效果分析</li>
                                    <li><strong>方法</strong>：SIR模型、信息级联</li>
                                </ul>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 时序最短路径（考虑时间窗口）
MATCH (start:Event {type: 'start'}),
      (end:Event {type: 'end'})
CALL gds.shortestPath.dijkstra.stream('temporalGraph', {
    sourceNode: start,
    targetNode: end,
    relationshipWeightProperty: 'duration',
    startTimeProperty: 'startTime',
    endTimeProperty: 'endTime'
})
YIELD nodeIds, path, cost
RETURN [nodeId IN nodeIds | gds.util.asNode(nodeId).eventTime] AS timeline

// 时序社区发现 - 追踪社区演变
MATCH (n:Person)
WITH gds.util.asNode(n).community AS community, n.eventTime AS time
RETURN community, 
       collect(DISTINCT time) AS evolution,
       count(*) AS size
ORDER BY size DESC

// 基于时间的链接预测（越近的关系权重越高）
MATCH (p1:Person {name: '张三'})-[r:FRIENDS_WITH]->(p2:Person)
WITH p1, p2, 
     r.since AS established,
     datetime().epochSeconds - established.epochSeconds AS ageInSeconds,
     1.0 / (1 / 86400) AS recencyWeight  + ageInSeconds // 每天衰减
RETURN p2.name AS friend, recencyWeight
ORDER BY recencyWeight DESC
LIMIT 10

// 时序PageRank（考虑时间衰减）
MATCH (n)
WITH gds.pageRank.stream('temporalGraph', {
    nodeWeightProperty: 'importance',
    temporalProperty: 'timestamp',
    decayFactor: 0.95
}) YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>算法选择指南</h3>
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>应用场景</th>
                                    <th>推荐算法</th>
                                    <th>GDS 函数</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>识别关键人物/节点</td>
                                    <td>PageRank, Betweenness</td>
                                    <td>gds.pageRank, gds.betweenness</td>
                                </tr>
                                <tr>
                                    <td>用户分群/社区发现</td>
                                    <td>Louvain, Label Propagation</td>
                                    <td>gds.louvain, gds.labelPropagation</td>
                                </tr>
                                <tr>
                                    <td>好友/商品推荐</td>
                                    <td>Link Prediction, Node2Vec</td>
                                    <td>gds.linkPrediction, gds.node2vec</td>
                                </tr>
                                <tr>
                                    <td>路径规划/导航</td>
                                    <td>Shortest Path, A*</td>
                                    <td>gds.shortestPath.dijkstra</td>
                                </tr>
                                <tr>
                                    <td>相似用户/物品</td>
                                    <td>Jaccard, Cosine, Node Similarity</td>
                                    <td>gds.nodeSimilarity</td>
                                </tr>
                                <tr>
                                    <td>特征学习/嵌入</td>
                                    <td>FastRP, GraphSAGE</td>
                                    <td>gds.fastRP, gds.graphSage</td>
                                </tr>
                                <tr>
                                    <td>分类/预测</td>
                                    <td>GNN, GraphSAGE</td>
                                    <td>gds.graphSage.train</td>
                                </tr>
                                <tr>
                                    <td>欺诈检测</td>
                                    <td>Community Detection + Anomaly</td>
                                    <td>gds.louvain + gds.beta.anomaly</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <section id="cypher" class="section section-alt">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-code"></i>
                    Cypher 查询语言
                </h2>
                <div class="section-content">
                    <div class="tutorial-block">
                        <h3 id="basic-syntax">基础语法</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 创建节点
CREATE (p:Person {name: '张三', age: 30})

// 创建关系
MATCH (p:Person {name: '张三'}), (c:Company {name: 'ABC公司'})
CREATE (p)-[:WORKS_FOR {since: 2020}]->(c)

// 查询节点
MATCH (p:Person)
WHERE p.age > 25
RETURN p.name, p.age

// 查询关系
MATCH (p:Person)-[r:WORKS_FOR]->(c:Company)
RETURN p.name, c.name, r.since</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>高级查询</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 多跳查询
MATCH (p:Person)-[:FRIEND_OF]->(friend)-[:WORKS_FOR]->(c:Company)
RETURN p.name, friend.name, c.name

// 可变长度路径
MATCH path = (p:Person)-[:KNOWS*1..3]->(other)
RETURN p.name, other.name, length(path) as degrees

// 聚合查询
MATCH (c:Company)<-[:WORKS_FOR]-(p:Person)
RETURN c.name, count(p) as employee_count
ORDER BY employee_count DESC

// 推荐查询（共同好友）
MATCH (person:Person {name: '张三'})-[:FRIEND_OF]->(friend)-[:FRIEND_OF]->(potential)
WHERE NOT (person)-[:FRIEND_OF]->(potential) AND person <> potential
RETURN potential.name, count(friend) as mutual_friends
ORDER BY mutual_friends DESC</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>模式匹配</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 可选关系
MATCH (p:Person)-[r:WORKS_FOR?]->(c:Company)
RETURN p.name, r.since, c.name

// 可变长度路径（最短路径）
MATCH path = shortestPath((p1:Person {name: '张三'})-[*]-(p2:Person {name: '李四'}))
RETURN path

// 所有简单路径
MATCH path = (p1:Person)-[:KNOWS*]->(p2:Person)
WHERE p1.name = '张三' AND p2.name = '李四'
RETURN path

// 有向路径查询
MATCH (p1:Person)-[:MANAGES*1..3]->(p2:Person)
RETURN p1.name as manager, p2.name as subordinate</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>聚合与分组</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 分组统计
MATCH (p:Person)-[:WORKS_FOR]->(c:Company)
RETURN c.name, count(p) as employee_count, 
       avg(p.age) as avg_age, 
       max(p.salary) as max_salary
ORDER BY employee_count DESC

// 多级分组
MATCH (p:Person)-[:WORKS_FOR]->(c:Company)
RETURN c.industry, c.name, count(p) as count
ORDER BY c.industry, count DESC

// 列表聚合
MATCH (p:Person)-[:HAS_SKILL]->(s:Skill)
RETURN p.name, collect(s.name) as skills

// 去重聚合
MATCH (p:Person)-[:WORKS_FOR]->(c:Company)
RETURN c.name, count(DISTINCT p.department) as departments</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>常用函数</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 字符串函数
MATCH (p:Person)
RETURN p.name, 
       toUpper(p.name) as upper_name,
       substring(p.name, 0, 3) as first_three,
       size(p.name) as name_length

// 数学函数
MATCH (p:Person)
RETURN p.name, p.age, 
       abs(p.age - 30) as age_diff,
       round(p.age * 1.5) as rounded,
       p.age % 10 as remainder

// 日期时间函数
MATCH (p:Person)-[r:WORKS_FOR]->(c:Company)
RETURN p.name, 
       date().year - p.birthYear as current_age,
       duration.between(r.since, date()).years as years_worked,
       datetime().year as current_year

// 路径函数
MATCH path = (p:Person)-[:KNOWS*]->(other)
RETURN p.name, other.name, 
       length(path) as hops,
       nodes(path) as path_nodes,
       relationships(path) as path_rels</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>子查询</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// CALL 子查询（2026新增）
MATCH (p:Person)
CALL {
    WITH p
    MATCH (p)-[:WORKS_FOR]->(c:Company)
    RETURN count(c) as company_count
}
RETURN p.name, company_count

// EXISTS 子查询
MATCH (p:Person)
WHERE EXISTS {
    MATCH (p)-[:WORKS_FOR]->(:Company {name: 'ABC公司'})
}
RETURN p.name

// 列表投影
MATCH (p:Person)
RETURN p.name, [skill IN p.skills WHERE skill.level > 3 | skill.name] as advanced_skills</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>数据修改</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 创建节点和关系
CREATE (p:Person {name: '王五', age: 35})
CREATE (c:Company {name: 'XYZ公司', founded: 2015})
CREATE (p)-[:WORKS_FOR {since: 2021, position: '经理'}]->(c)

// 更新节点属性
MATCH (p:Person {name: '张三'})
SET p.age = 31, p.salary = 50000

// 添加/删除标签
MATCH (p:Person {name: '张三'})
SET p:Manager
MATCH (p:Person {name: '张三'})
REMOVE p:Manager

// 删除节点和关系
MATCH (p:Person {name: '王五'})-[r:WORKS_FOR]->()
DELETE r, p

// 批量更新
MATCH (p:Person)
WHERE p.age > 30
SET p.salary = p.salary * 1.1</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>性能优化技巧</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 使用索引加速查询
CREATE INDEX person_name_index FOR (p:Person) ON (p.name)
CREATE INDEX company_industry_index FOR (c:Company) ON (c.industry)

// 使用约束保证数据唯一性
CREATE CONSTRAINT person_id_unique FOR (p:Person) REQUIRE p.id IS UNIQUE

// 优化：先使用索引过滤
MATCH (p:Person {name: '张三'})-[r:WORKS_FOR]->(c:Company)
WHERE c.industry = '技术'
RETURN p, c

// 使用 LIMIT 限制结果集
MATCH (p:Person)-[:WORKS_FOR]->(c:Company)
RETURN p.name, c.name
LIMIT 100

// 使用 PROFILE 分析查询性能
PROFILE MATCH (p:Person)-[:WORKS_FOR]->(c:Company)
RETURN p.name, c.name

// 避免 Cartesian product
// 不好的写法：
MATCH (p:Person), (c:Company)
RETURN p, c

// 好的写法：
MATCH (p:Person)-[:WORKS_FOR]->(c:Company)
RETURN p, c</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>图算法（Graph Data Science）</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// PageRank 算法 - 识别重要节点
CALL gds.pageRank.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name as name, score
ORDER BY score DESC
LIMIT 10

// 社区发现 - Louvain 算法
CALL gds.louvain.stream('myGraph')
YIELD nodeId, communityId
RETURN communityId, count(*) as community_size
ORDER BY community_size DESC

// 最短路径算法
MATCH (source:Person {name: '张三'}), (target:Person {name: '李四'})
CALL gds.shortestPath.stream('myGraph', {
    sourceNode: source,
    targetNode: target
})
YIELD index, nodeIds
RETURN [nodeId IN nodeIds | gds.util.asNode(nodeId).name] as path

// 连通分量
CALL gds.wcc.stream('myGraph')
YIELD nodeId, componentId
RETURN componentId, count(*) as size
ORDER BY size DESC</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>实用查询示例</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 查找没有好友的人
MATCH (p:Person)
WHERE NOT (p)-[:FRIEND_OF]->()
RETURN p.name

// 查找拥有最多技能的人
MATCH (p:Person)-[r:HAS_SKILL]->(s:Skill)
WITH p, count(s) as skill_count
ORDER BY skill_count DESC
RETURN p.name, skill_count
LIMIT 5

// 查找共同技能
MATCH (p1:Person {name: '张三'})-[:HAS_SKILL]->(s:Skill)<-[:HAS_SKILL]-(p2:Person)
RETURN p2.name, collect(s.name) as common_skills
ORDER BY size(common_skills) DESC

// 查找技能路径
MATCH (p1:Person {name: '张三'})-[:HAS_SKILL*]->(s:Skill)<-[:HAS_SKILL*]-(p2:Person {name: '李四'})
RETURN p1.name, p2.name, collect(DISTINCT s.name) as connecting_skills

// 时间窗口查询
MATCH (p:Person)-[r:WORKS_FOR]->(c:Company)
WHERE r.since >= date('2020-01-01') AND r.since <= date('2025-12-31')
RETURN p.name, c.name, r.since
ORDER BY r.since DESC</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>2026 新增特性</h3>
                        <ul>
                            <li><strong>模式匹配优化</strong>：更智能的查询规划器</li>
                            <li><strong>子查询支持</strong>：CALL {} 语法增强</li>
                            <li><strong>函数扩展</strong>：新增 50+ 内置函数</li>
                            <li><strong>性能提升</strong>：查询速度提升 40%</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section id="modeling" class="section">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-sitemap"></i>
                    数据建模最佳实践
                </h2>
                <div class="section-content">
                    <div class="modeling-guide">
                        <h3>建模原则</h3>
                        <div class="principle-card">
                            <h4>1. 关注关系而非表结构</h4>
                            <p>图数据库建模应该从关系的角度思考，而不是传统的关系型数据库表结构。让数据关系自然呈现。</p>
                        </div>
                        <div class="principle-card">
                            <h4>2. 使用标签进行分类</h4>
                            <p>合理使用标签来对节点进行分类，便于查询和索引。一个节点可以有多个标签。</p>
                        </div>
                        <div class="principle-card">
                            <h4>3. 关系命名要语义化</h4>
                            <p>关系名称应该清楚地表达两个节点之间的语义，如 WORKS_FOR、FRIENDS_WITH、LOCATED_IN 等。</p>
                        </div>
                        <div class="principle-card">
                            <h4>4. 避免过度规范化</h4>
                            <p>图数据库允许一定的数据冗余，为了提高查询性能，可以在节点上存储必要的属性。</p>
                        </div>
                    </div>

                    <div class="modeling-example">
                        <h3>社交网络建模示例</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 创建用户
CREATE (u1:User {id: 'u1', name: 'Alice', age: 28})
CREATE (u2:User {id: 'u2', name: 'Bob', age: 32})
CREATE (u3:User {id: 'u3', name: 'Charlie', age: 25})

// 创建帖子
CREATE (p1:Post {id: 'p1', content: 'Hello Neo4j!', created: datetime()})

// 创建关系
MATCH (u1:User {id: 'u1'}), (p1:Post {id: 'p1'})
CREATE (u1)-[:POSTED]->(p1)

MATCH (u1:User {id: 'u1'}), (u2:User {id: 'u2'})
CREATE (u1)-[:FOLLOWS]->(u2)
CREATE (u2)-[:FRIENDS_WITH]->(u1)</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="features" class="section section-alt">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-rocket"></i>
                    Neo4j 5.x/6.x 新特性
                </h2>
                <div class="section-content">
                    <div class="feature-grid">
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-bolt"></i>
                            </div>
                            <h3>性能提升</h3>
                            <p>查询性能提升 40%，存储空间节省 30%。新的查询优化器更智能，自动选择最佳执行计划。</p>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-shield-alt"></i>
                            </div>
                            <h3>安全性增强</h3>
                            <p>支持基于角色的访问控制（RBAC），细粒度的权限管理，加密连接和存储。</p>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-expand-arrows-alt"></i>
                            </div>
                            <h3>云原生支持</h3>
                            <p>完整的云原生架构，支持 Kubernetes 部署，自动扩缩容，多区域复制。</p>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-brain"></i>
                            </div>
                            <h3>AI/ML 集成</h3>
                            <p>内置图算法库（Graph Data Science），支持机器学习模型训练和推理。包含65+图算法、图神经网络、预测模型等。</p>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-code-branch"></i>
                            </div>
                            <h3>Cypher 增强</h3>
                            <p>支持子查询、窗口函数、更强大的模式匹配，语法更接近 SQL。</p>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-plug"></i>
                            </div>
                            <h3>驱动更新</h3>
                            <p>所有官方驱动更新到 5.x 版本，支持异步编程，性能优化。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="aiml" class="section section-alt">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-brain"></i>
                    AI/ML 集成详解
                </h2>
                <div class="section-content">
                    <div class="tutorial-block">
                        <h3>Neo4j Graph Data Science (GDS) 概述</h3>
                        <p>Neo4j Graph Data Science 是一个强大的图算法和机器学习库，提供了65+种图算法，支持节点嵌入、链接预测、图神经网络等高级功能。</p>
                        <ul>
                            <li><strong>图算法库</strong>：中心性算法、社区发现算法、路径查找算法</li>
                            <li><strong>机器学习管道</strong>：特征工程、模型训练、预测和评估</li>
                            <li><strong>图神经网络</strong>：图卷积网络、图注意力网络</li>
                            <li><strong>节点嵌入</strong>：Node2Vec、FastRP、GraphSAGE</li>
                        </ul>
                    </div>

                    <div class="tutorial-block">
                        <h3>1. 中心性算法 - 识别关键节点</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// PageRank - 识别网络中最有影响力的节点
CALL gds.pageRank.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name as name, score
ORDER BY score DESC
LIMIT 10

// Betweenness Centrality - 识别网络中的桥梁节点
CALL gds.betweenness.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name as name, score
ORDER BY score DESC
LIMIT 10

// Degree Centrality - 识别连接最多的节点
CALL gds.degree.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name as name, score
ORDER BY score DESC
LIMIT 10</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>2. 社区发现算法 - 识别社群结构</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// Louvain 算法 - 发现网络中的社区
CALL gds.louvain.stream('myGraph')
YIELD nodeId, communityId
RETURN communityId, count(*) as community_size
ORDER BY community_size DESC

// Label Propagation - 快速社区发现
CALL gds.labelPropagation.stream('myGraph')
YIELD nodeId, communityId
RETURN communityId, collect(gds.util.asNode(nodeId).name) as members
ORDER BY size(members) DESC
LIMIT 5

// Weakly Connected Components - 识别连通分量
CALL gds.wcc.stream('myGraph')
YIELD nodeId, componentId
RETURN componentId, count(*) as size
ORDER BY size DESC</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>3. 节点嵌入 - 将节点转换为向量表示</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// FastRP - 快速随机投影嵌入
CALL gds.fastRP.write('myGraph', {
    embeddingDimension: 256,
    relationshipWeightProperty: 'weight',
    writeProperty: 'embedding'
})

// Node2Vec - 基于随机游走的节点嵌入
CALL gds.node2vec.stream('myGraph', {
    embeddingDimension: 128,
    walkLength: 80,
    walksPerNode: 10,
    returnFactor: 1.0,
    inOutFactor: 1.0
})
YIELD nodeId, embedding
RETURN gds.util.asNode(nodeId).name as name, embedding[0..5] as preview

// GraphSAGE - 图神经网络嵌入
CALL gds.graphSage.train('myGraph', {
    modelName: 'myModel',
    featureProperties: ['age', 'salary'],
    embeddingDimension: 64,
    aggregator: 'mean',
    epochs: 5
})</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>4. 链接预测 - 预测未来可能的关系</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 使用 Adamic-Adar 系数预测链接
MATCH (p1:Person)
CALL gds.linkPrediction.adamicAdar.stream('myGraph', {
    sourceNode: p1,
    targetCandidates: [p2, p3, p4]
})
YIELD node1, node2, score
RETURN node1.name as person1, node2.name as person2, score
ORDER BY score DESC
LIMIT 10

// 使用 Common Neighbors 预测链接
MATCH (p1:Person {name: '张三'})
CALL gds.linkPrediction.commonNeighbors.stream('myGraph', {
    sourceNode: p1
})
YIELD node2, score
RETURN node2.name as potential_friend, score
ORDER BY score DESC
LIMIT 10

// 使用 Random Forest 链接预测模型
CALL gds.alpha.ml.linkPrediction.train('myGraph', {
    modelName: 'linkPredictionModel',
    featureProperties: ['adamicAdar', 'commonNeighbors', 'preferentialAttachment']
})</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>5. 相似度计算</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// Jaccard 相似度 - 计算节点间的相似性
MATCH (p1:Person {name: '张三'})
CALL gds.nodeSimilarity.jaccard.stream('myGraph', {
    sourceNode: p1
})
YIELD node2, similarity
RETURN node2.name as similar_person, similarity
ORDER BY similarity DESC
LIMIT 10

// Cosine 相似度 - 基于嵌入向量的相似度
MATCH (p1:Person {name: '张三'}), (p2:Person)
WHERE p1 <> p2
WITH p1, p2, gds.similarity.cosine(p1.embedding, p2.embedding) as similarity
RETURN p2.name, similarity
ORDER BY similarity DESC
LIMIT 10

// Euclidean 距离 - 基于嵌入向量的距离
MATCH (p1:Person {name: '张三'}), (p2:Person)
WHERE p1 <> p2
WITH p1, p2, gds.similarity.euclideanDistance(p1.embedding, p2.embedding) as distance
RETURN p2.name, distance
ORDER BY distance ASC
LIMIT 10</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>6. 实战案例：推荐系统</h3>
                        <p>使用图算法构建个性化推荐系统</p>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 步骤1: 计算用户相似度
CALL gds.nodeSimilarity.write('userGraph', {
    writeRelationshipType: 'SIMILAR_TO',
    writeProperty: 'similarityScore',
    topK: 10
})

// 步骤2: 基于相似用户推荐商品
MATCH (targetUser:User {id: 'user1'})-[:SIMILAR_TO]->(similarUser:User)
MATCH (similarUser)-[:RATED]->(product:Product)
WHERE NOT (targetUser)-[:RATED]->(product)
WITH targetUser, product, avg(similarUser.similarityScore) as avg_similarity
RETURN product.name, avg_similarity
ORDER BY avg_similarity DESC
LIMIT 10

// 步骤3: 使用 PageRank 提升热门商品权重
CALL gds.pageRank.stream('productGraph', {
    relationshipWeightProperty: 'rating'
})
YIELD nodeId, score
WITH gds.util.asNode(nodeId) as product, score
ORDER BY score DESC
LIMIT 10
RETURN product.name, score as popularity_score</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>7. 实战案例：欺诈检测</h3>
                        <p>使用图算法识别欺诈网络模式</p>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 步骤1: 检测异常连接模式
CALL gds.louvain.stream('transactionGraph')
YIELD nodeId, communityId
WITH communityId, count(*) as community_size
WHERE community_size < 5
RETURN communityId as suspicious_community, community_size

// 步骤2: 计算节点的中心性指标
CALL gds.degree.stream('transactionGraph')
YIELD nodeId, score
WITH gds.util.asNode(nodeId) as node, score
WHERE score > 100
RETURN node.id as high_degree_node, score

// 步骤3: 检测环形交易模式
MATCH (a:Account)-[t1:TRANSFER]->(b:Account)
MATCH (b)-[t2:TRANSFER]->(c:Account)
MATCH (c)-[t3:TRANSFER]->(a)
WHERE t1.amount = t2.amount AND t2.amount = t3.amount
RETURN a.id, b.id, c.id, t1.amount, t1.datetime

// 步骤4: 使用弱连通分量发现孤立欺诈团伙
CALL gds.wcc.stream('transactionGraph')
YIELD nodeId, componentId
WITH componentId, collect(gds.util.asNode(nodeId).id) as accounts
WHERE size(accounts) >= 3 AND size(accounts) <= 10
RETURN componentId, accounts as suspicious_group</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>8. 实战案例：知识图谱问答</h3>
                        <p>结合图算法和自然语言处理</p>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 步骤1: 构建知识图谱
CREATE (p:Person {name: '张三', profession: '医生'})
CREATE (h:Hospital {name: '北京医院', location: '北京'})
CREATE (d:Disease {name: '高血压', category: '心血管'})
CREATE (p)-[:WORKS_AT]->(h)
CREATE (p)-[:TREATS]->(d)

// 步骤2: 查询医生治疗过的疾病
MATCH (p:Person {profession: '医生'})-[:TREATS]->(d:Disease)
RETURN p.name as doctor, collect(d.name) as diseases

// 步骤3: 查询某种疾病的治疗专家
MATCH (d:Disease {name: '高血压'})<-[:TREATS]-(p:Person)
RETURN p.name as specialist, p.workplace as hospital

// 步骤4: 使用路径查找发现相关疾病
MATCH (d1:Disease {name: '高血压'})-[:RELATED_TO*1..2]-(d2:Disease)
RETURN d1.name, d2.name, length(path) as distance</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>9. 图神经网络 (GNN) 应用</h3>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 使用 GraphSAGE 进行节点分类
CALL gds.graphSage.train('myGraph', {
    modelName: 'nodeClassifier',
    featureProperties: ['age', 'income', 'score'],
    embeddingDimension: 128,
    aggregator: 'mean',
    epochs: 10,
    batchSize: 64
})

// 使用训练好的模型进行预测
CALL gds.graphSage.predict.stream('myGraph', {
    modelName: 'nodeClassifier'
})
YIELD nodeId, predictedLabel
RETURN gds.util.asNode(nodeId).name as name, predictedLabel

// 图卷积网络 (GCN) 用于链接预测
CALL gds.alpha.ml.linkPrediction.predict('myGraph', {
    modelName: 'gcnLinkPredictor',
    topK: 10
})
YIELD node1, node2, probability
RETURN node1.name, node2.name, probability
ORDER BY probability DESC</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>10. 性能优化最佳实践</h3>
                        <ul>
                            <li><strong>使用命名图投影</strong>：预先创建图投影，避免重复计算</li>
                            <li><strong>批量处理</strong>：使用 `stream` 模式处理大数据集</li>
                            <li><strong>并行计算</strong>：利用 GDS 的并行计算能力</li>
                            <li><strong>内存管理</strong>：合理配置内存参数，避免 OOM</li>
                            <li><strong>缓存结果</strong>：将常用算法结果写入数据库</li>
                        </ul>
                        <div class="code-block">
                            <pre><code class="language-cypher">// 创建命名图投影
CALL gds.graph.project('myGraph', ['Person', 'Company'], ['WORKS_FOR', 'KNOWS'])

// 使用批量流式处理
CALL gds.pageRank.stream.estimate('myGraph', {
    relationshipWeightProperty: 'weight'
})
YIELD requiredMemory

// 写入结果到数据库
CALL gds.pageRank.write('myGraph', {
    writeProperty: 'pagerankScore'
})

// 释放图投影内存
CALL gds.graph.drop('myGraph')</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="drivers" class="section">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-code"></i>
                    编程语言连接指南
                </h2>
                <div class="section-content">
                    <div class="tutorial-block">
                        <h3>Python 连接 Neo4j</h3>
                        <p>Neo4j 官方提供了 Python 驱动程序 `neo4j-driver`，支持异步和同步操作。</p>

                        <h4>安装驱动</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher"># 使用 pip 安装
pip install neo4j

# 或使用 conda
conda install -c conda-forge neo4j-python-driver</code></pre>
                        </div>

                        <h4>基础连接示例</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher"># basic_connection.py
from neo4j import GraphDatabase

class Neo4jConnection:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def query(self, query, parameters=None):
        with self.driver.session() as session:
            result = session.run(query, parameters)
            return [record for record in result]

# 使用示例
if __name__ == "__main__":
    conn = Neo4jConnection(
        uri="bolt://localhost:7687",
        user="neo4j",
        password="your_password"
    )

    # 执行查询
    result = conn.query("MATCH (n) RETURN n LIMIT 5")
    for record in result:
        print(record)

    conn.close()</code></pre>
                        </div>

                        <h4>创建节点和关系</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher"># create_data.py
from neo4j import GraphDatabase

def create_person(tx, name, age):
    result = tx.run(
        "CREATE (p:Person {name: $name, age: $age}) "
        "RETURN p",
        name=name, age=age
    )
    return result.single()[0]

def create_relationship(tx, person1, person2):
    result = tx.run(
        "MATCH (p1:Person {name: $person1}) "
        "MATCH (p2:Person {name: $person2}) "
        "CREATE (p1)-[:FRIENDS_WITH]->(p2) "
        "RETURN p1, p2",
        person1=person1, person2=person2
    )
    return result.single()

# 使用示例
driver = GraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "password"))

with driver.session() as session:
    # 创建人员
    session.execute_write(create_person, "张三", 30)
    session.execute_write(create_person, "李四", 28)
    session.execute_write(create_person, "王五", 32)

    # 创建关系
    session.execute_write(create_relationship, "张三", "李四")
    session.execute_write(create_relationship, "李四", "王五")

driver.close()</code></pre>
                        </div>

                        <h4>查询数据</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher"># query_data.py
from neo4j import GraphDatabase

def get_friends(tx, person_name):
    result = tx.run(
        "MATCH (p:Person {name: $name})-[:FRIENDS_WITH]->(friend) "
        "RETURN friend.name as friend_name, friend.age as friend_age",
        name=person_name
    )
    return [{"name": record["friend_name"], "age": record["friend_age"]}
            for record in result]

def get_shortest_path(tx, person1, person2):
    result = tx.run(
        "MATCH path = shortestPath((p1:Person {name: $p1})-[*]-(p2:Person {name: $p2})) "
        "RETURN [node IN nodes(path) | node.name] as path",
        p1=person1, p2=person2
    )
    return result.single()["path"]

# 使用示例
driver = GraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "password"))

with driver.session() as session:
    # 查询朋友
    friends = session.execute_read(get_friends, "张三")
    print(f"张三的朋友: {friends}")

    # 查询最短路径
    path = session.execute_read(get_shortest_path, "张三", "王五")
    print(f"从张三到王五的路径: {path}")

driver.close()</code></pre>
                        </div>

                        <h4>异步操作示例</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher"># async_example.py
from neo4j import AsyncGraphDatabase

class AsyncNeo4jConnection:
    def __init__(self, uri, user, password):
        self.driver = AsyncGraphDatabase.driver(uri, auth=(user, password))

    async def close(self):
        await self.driver.close()

    async def query(self, query, parameters=None):
        async with self.driver.session() as session:
            result = await session.run(query, parameters)
            return [record async for record in result]

    async def batch_create(self, persons):
        async with self.driver.session() as session:
            for person in persons:
                await session.run(
                    "CREATE (p:Person {name: $name, age: $age})",
                    name=person["name"], age=person["age"]
                )

# 使用示例
import asyncio

async def main():
    conn = AsyncNeo4jConnection(
        uri="bolt://localhost:7687",
        user="neo4j",
        password="password"
    )

    # 批量创建
    persons = [
        {"name": "Alice", "age": 25},
        {"name": "Bob", "age": 30},
        {"name": "Charlie", "age": 28}
    ]
    await conn.batch_create(persons)

    # 查询数据
    result = await conn.query("MATCH (p:Person) RETURN p.name as name")
    for record in result:
        print(record["name"])

    await conn.close()

asyncio.run(main())</code></pre>
                        </div>

                        <h4>使用 OGM (Object Graph Mapper)</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher"># 安装 neomodel
# pip install neomodel

# ogm_example.py
from neomodel import StructuredNode, StringProperty, IntegerProperty, RelationshipTo, config

# 配置连接
config.DATABASE_URL = 'bolt://neo4j:password@localhost:7687'

class Person(StructuredNode):
    name = StringProperty(unique_index=True, required=True)
    age = IntegerProperty()
    friends = RelationshipTo('Person', 'FRIENDS_WITH')

# 使用示例
# 创建节点
person1 = Person(name='张三', age=30).save()
person2 = Person(name='李四', age=28).save()

# 创建关系
person1.friends.connect(person2)

# 查询数据
person = Person.nodes.get(name='张三')
print(f"{person.name} 的年龄: {person.age}")

# 查询朋友
for friend in person.friends:
    print(f"朋友: {friend.name}, 年龄: {friend.age}")

# 批量查询
young_people = Person.nodes.filter(age__lt=30)
for person in young_people:
    print(f"年轻人: {person.name}")</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>Golang 连接 Neo4j</h3>
                        <p>Neo4j 官方提供了 Go 驱动程序 `github.com/neo4j/neo4j-go-driver/v5`，支持完整的功能。</p>

                        <h4>安装驱动</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher"># 使用 go get 安装
go get github.com/neo4j/neo4j-go-driver/v5/neo4j</code></pre>
                        </div>

                        <h4>基础连接示例</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher">// basic_connection.go
package main

import (
    "fmt"
    "log"

    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {
    driver, err := neo4j.NewDriver(
        "bolt://localhost:7687",
        neo4j.BasicAuth("neo4j", "password", ""))
    if err != nil {
        log.Fatal(err)
    }
    defer driver.Close()

    // 验证连接
    err = driver.VerifyConnectivity()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("连接成功!")

    // 执行查询
    session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeRead})
    defer session.Close()

    result, err := session.Run("MATCH (n) RETURN n LIMIT 5", nil)
    if err != nil {
        log.Fatal(err)
    }

    for result.Next() {
        record := result.Record()
        fmt.Println(record)
    }

    if err = result.Err(); err != nil {
        log.Fatal(err)
    }
}</code></pre>
                        </div>

                        <h4>创建节点和关系</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher">// create_data.go
package main

import (
    "fmt"
    "log"

    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func createPerson(driver neo4j.Driver, name string, age int) error {
    session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
    defer session.Close()

    _, err := session.Run(
        "CREATE (p:Person {name: $name, age: $age})",
        map[string]interface{}{
            "name": name,
            "age":  age,
        })
    return err
}

func createRelationship(driver neo4j.Driver, person1, person2 string) error {
    session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
    defer session.Close()

    _, err := session.Run(
        "MATCH (p1:Person {name: $p1}) "+
            "MATCH (p2:Person {name: $p2}) "+
            "CREATE (p1)-[:FRIENDS_WITH]->(p2)",
        map[string]interface{}{
            "p1": person1,
            "p2": person2,
        })
    return err
}

func main() {
    driver, err := neo4j.NewDriver(
        "bolt://localhost:7687",
        neo4j.BasicAuth("neo4j", "password", ""))
    if err != nil {
        log.Fatal(err)
    }
    defer driver.Close()

    // 创建人员
    persons := []struct {
        name string
        age  int
    }{
        {"张三", 30},
        {"李四", 28},
        {"王五", 32},
    }

    for _, p := range persons {
        if err := createPerson(driver, p.name, p.age); err != nil {
            log.Fatal(err)
        }
        fmt.Printf("创建人员: %s\n", p.name)
    }

    // 创建关系
    relationships := [][2]string{
        {"张三", "李四"},
        {"李四", "王五"},
    }

    for _, rel := range relationships {
        if err := createRelationship(driver, rel[0], rel[1]); err != nil {
            log.Fatal(err)
        }
        fmt.Printf("创建关系: %s -> %s\n", rel[0], rel[1])
    }

    fmt.Println("数据创建完成!")
}</code></pre>
                        </div>

                        <h4>查询数据</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher">// query_data.go
package main

import (
    "fmt"
    "log"

    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

type Friend struct {
    Name string
    Age  int
}

func getFriends(driver neo4j.Driver, personName string) ([]Friend, error) {
    session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeRead})
    defer session.Close()

    result, err := session.Run(
        "MATCH (p:Person {name: $name})-[:FRIENDS_WITH]->(friend) "+
            "RETURN friend.name as name, friend.age as age",
        map[string]interface{}{
            "name": personName,
        })
    if err != nil {
        return nil, err
    }

    var friends []Friend
    for result.Next() {
        record := result.Record()
        name, _ := record.Get("name")
        age, _ := record.Get("age")
        friends = append(friends, Friend{
            Name: name.(string),
            Age:  int(age.(int64)),
        })
    }

    if err = result.Err(); err != nil {
        return nil, err
    }

    return friends, nil
}

func getShortestPath(driver neo4j.Driver, person1, person2 string) ([]string, error) {
    session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeRead})
    defer session.Close()

    result, err := session.Run(
        "MATCH path = shortestPath((p1:Person {name: $p1})-[*]-(p2:Person {name: $p2})) "+
            "RETURN [node IN nodes(path) | node.name] as path",
        map[string]interface{}{
            "p1": person1,
            "p2": person2,
        })
    if err != nil {
        return nil, err
    }

    if result.Next() {
        record := result.Record()
        path, _ := record.Get("path")
        return path.([]string), nil
    }

    return nil, nil
}

func main() {
    driver, err := neo4j.NewDriver(
        "bolt://localhost:7687",
        neo4j.BasicAuth("neo4j", "password", ""))
    if err != nil {
        log.Fatal(err)
    }
    defer driver.Close()

    // 查询朋友
    friends, err := getFriends(driver, "张三")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("张三的朋友:\n")
    for _, friend := range friends {
        fmt.Printf("  - %s (年龄: %d)\n", friend.Name, friend.Age)
    }

    // 查询最短路径
    path, err := getShortestPath(driver, "张三", "王五")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("从张三到王五的路径: %v\n", path)
}</code></pre>
                        </div>

                        <h4>事务处理</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher">// transaction.go
package main

import (
    "fmt"
    "log"

    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func transferMoney(driver neo4j.Driver, fromUser, toUser string, amount int) error {
    session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
    defer session.Close()

    // 使用事务
    _, err := session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
        // 检查发送者余额
        result, err := tx.Run(
            "MATCH (u:User {name: $name}) RETURN u.balance as balance",
            map[string]interface{}{"name": fromUser})
        if err != nil {
            return nil, err
        }

        if !result.Next() {
            return nil, fmt.Errorf("用户不存在: %s", fromUser)
        }

        balance, _ := result.Record().Get("balance")
        if balance.(int64) < int64(amount) {
            return nil, fmt.Errorf("余额不足")
        }

        // 扣除发送者余额
        _, err = tx.Run(
            "MATCH (u:User {name: $name}) SET u.balance = u.balance - $amount",
            map[string]interface{}{
                "name":   fromUser,
                "amount": amount,
            })
        if err != nil {
            return nil, err
        }

        // 增加接收者余额
        _, err = tx.Run(
            "MATCH (u:User {name: $name}) SET u.balance = u.balance + $amount",
            map[string]interface{}{
                "name":   toUser,
                "amount": amount,
            })
        if err != nil {
            return nil, err
        }

        // 创建交易记录
        _, err = tx.Run(
            "MATCH (from:User {name: $from}), (to:User {name: $to}) "+
                "CREATE (from)-[:TRANSFERRED {amount: $amount, date: datetime()}]->(to)",
            map[string]interface{}{
                "from":   fromUser,
                "to":     toUser,
                "amount": amount,
            })
        if err != nil {
            return nil, err
        }

        return nil, nil
    })

    return err
}

func main() {
    driver, err := neo4j.NewDriver(
        "bolt://localhost:7687",
        neo4j.BasicAuth("neo4j", "password", ""))
    if err != nil {
        log.Fatal(err)
    }
    defer driver.Close()

    // 执行转账
    err = transferMoney(driver, "张三", "李四", 100)
    if err != nil {
        log.Printf("转账失败: %v\n", err)
    } else {
        fmt.Println("转账成功!")
    }
}</code></pre>
                        </div>

                        <h4>连接池配置</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher">// connection_pool.go
package main

import (
    "fmt"
    "log"
    "time"

    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {
    // 配置连接池
    driver, err := neo4j.NewDriver(
        "bolt://localhost:7687",
        neo4j.BasicAuth("neo4j", "password", ""),
        func(config *neo4j.Config) {
            // 连接池大小
            config.MaxConnectionPoolSize = 50
            config.MaxTransactionRetryTime = 30 * time.Second
            config.ConnectionAcquisitionTimeout = 2 * time.Minute

            // 重试配置
            config.MaxConnectionLifetime = 1 * time.Hour
            config.ConnectionTimeout = 30 * time.Second

            // 日志
            config.Log = neo4j.ConsoleLogger(neo4j.INFO)
        })
    if err != nil {
        log.Fatal(err)
    }
    defer driver.Close()

    // 验证连接
    err = driver.VerifyConnectivity()
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("连接池状态:\n")
    fmt.Printf("  总连接数: %d\n", driver.TotalConnections())
    fmt.Printf("  空闲连接数: %d\n", driver.IdleConnections())

    // 执行查询
    session := driver.NewSession(neo4j.SessionConfig{
        AccessMode:      neo4j.AccessModeRead,
        Bookmarks:       []string{},
        DatabaseName:    "neo4j",
        FetchSize:       1000,
        ImpersonatedUser: "",
    })
    defer session.Close()

    result, err := session.Run("MATCH (n) RETURN count(n) as count", nil)
    if err != nil {
        log.Fatal(err)
    }

    if result.Next() {
        count, _ := result.Record().Get("count")
        fmt.Printf("节点总数: %d\n", count)
    }
}</code></pre>
                        </div>

                        <h4>使用 ORM (GORM-like) 封装</h4>
                        <div class="code-block">
                            <pre><code class="language-cypher">// orm_example.go
package main

import (
    "fmt"
    "log"

    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// Repository 封装数据库操作
type PersonRepository struct {
    driver neo4j.Driver
}

type Person struct {
    Name string
    Age  int
}

func NewPersonRepository(driver neo4j.Driver) *PersonRepository {
    return &PersonRepository{driver: driver}
}

func (r *PersonRepository) Create(name string, age int) error {
    session := r.driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
    defer session.Close()

    _, err := session.Run(
        "CREATE (p:Person {name: $name, age: $age})",
        map[string]interface{}{
            "name": name,
            "age":  age,
        })
    return err
}

func (r *PersonRepository) FindByName(name string) (*Person, error) {
    session := r.driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeRead})
    defer session.Close()

    result, err := session.Run(
        "MATCH (p:Person {name: $name}) RETURN p.name as name, p.age as age",
        map[string]interface{}{"name": name})
    if err != nil {
        return nil, err
    }

    if result.Next() {
        record := result.Record()
        name, _ := record.Get("name")
        age, _ := record.Get("age")
        return &Person{
            Name: name.(string),
            Age:  int(age.(int64)),
        }, nil
    }

    return nil, fmt.Errorf("未找到用户")
}

func (r *PersonRepository) FindAll(limit int) ([]Person, error) {
    session := r.driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeRead})
    defer session.Close()

    result, err := session.Run(
        "MATCH (p:Person) RETURN p.name as name, p.age as age LIMIT $limit",
        map[string]interface{}{"limit": limit})
    if err != nil {
        return nil, err
    }

    var persons []Person
    for result.Next() {
        record := result.Record()
        name, _ := record.Get("name")
        age, _ := record.Get("age")
        persons = append(persons, Person{
            Name: name.(string),
            Age:  int(age.(int64)),
        })
    }

    return persons, nil
}

func (r *PersonRepository) Delete(name string) error {
    session := r.driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
    defer session.Close()

    _, err := session.Run(
        "MATCH (p:Person {name: $name}) DETACH DELETE p",
        map[string]interface{}{"name": name})
    return err
}

func main() {
    driver, err := neo4j.NewDriver(
        "bolt://localhost:7687",
        neo4j.BasicAuth("neo4j", "password", ""))
    if err != nil {
        log.Fatal(err)
    }
    defer driver.Close()

    repo := NewPersonRepository(driver)

    // 创建
    err = repo.Create("张三", 30)
    if err != nil {
        log.Fatal(err)
    }

    // 查询单个
    person, err := repo.FindByName("张三")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("找到用户: %s, 年龄: %d\n", person.Name, person.Age)

    // 查询所有
    persons, err := repo.FindAll(10)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("所有用户:\n")
    for _, p := range persons {
        fmt.Printf("  - %s (年龄: %d)\n", p.Name, p.Age)
    }

    // 删除
    err = repo.Delete("张三")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("删除成功!")
}</code></pre>
                        </div>
                    </div>

                    <div class="tutorial-block">
                        <h3>最佳实践</h3>
                        <ul>
                            <li><strong>连接管理</strong>：使用连接池，避免频繁创建和销毁连接</li>
                            <li><strong>事务处理</strong>：确保数据一致性，使用事务处理复杂操作</li>
                            <li><strong>错误处理</strong>：妥善处理错误和异常情况</li>
                            <li><strong>参数化查询</strong>：使用参数化查询防止注入攻击</li>
                            <li><strong>资源释放</strong>：确保 session、result 等资源正确释放</li>
                            <li><strong>性能优化</strong>：使用批量操作、索引优化查询性能</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section id="examples" class="section">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-laptop-code"></i>
                    实战示例
                </h2>
                <div class="section-content">
                    <div class="example-tabs">
                        <div class="tab-buttons">
                            <a href="#recommendation" class="tab-btn">推荐系统</a>
                            <a href="#fraud" class="tab-btn">欺诈检测</a>
                            <a href="#network" class="tab-btn">网络分析</a>
                        </div>

                        <div class="tab-content" id="recommendation">
                            <h3>基于图的推荐系统</h3>
                            <p>利用用户行为和物品关系构建知识图谱，实现精准推荐。</p>
                            <div class="code-block">
                                <pre><code class="language-cypher">// 查找与用户相似的其他用户
MATCH (u:User {id: 'user1'})-[:RATED]->(p:Product)<-[:RATED]-(other:User)
WITH u, other, count(p) as common_products
WHERE common_products > 2
MATCH (other)-[:RATED]->(rec:Product)
WHERE NOT (u)-[:RATED]->(rec)
RETURN rec.name, avg(r.rating) as avg_rating, count(r) as rating_count
ORDER BY avg_rating DESC
LIMIT 10</code></pre>
                            </div>
                        </div>

                        <div class="tab-content" id="fraud">
                            <h3>欺诈检测系统</h3>
                            <p>发现异常的交易模式和关联网络，识别潜在欺诈行为。</p>
                            <div class="code-block">
                                <pre><code class="language-cypher">// 检测环形转账模式
MATCH (a:Account)-[t1:TRANSFER]->(b:Account)
MATCH (b)-[t2:TRANSFER]->(c:Account)
MATCH (c)-[t3:TRANSFER]->(a)
WHERE t1.amount = t2.amount AND t2.amount = t3.amount
RETURN a.id, b.id, c.id, t1.amount, t1.datetime

// 检测短时间内多笔交易
MATCH (a:Account)-[t:TRANSFER]->(b:Account)
WHERE t.datetime > datetime() - duration('PT1H')
WITH a, count(t) as transfer_count
WHERE transfer_count > 50
RETURN a.id, transfer_count</code></pre>
                            </div>
                        </div>

                        <div class="tab-content" id="network">
                            <h3>社交网络分析</h3>
                            <p>分析社交网络中的影响力传播、社群发现和关键节点识别。</p>
                            <div class="code-block">
                                <pre><code class="language-cypher">// 查找影响力最大的用户（使用 PageRank）
CALL algo.pageRank.stream('User', 'FOLLOWS')
YIELD nodeId, score
RETURN algo.getNodeById(nodeId).name as user, score
ORDER BY score DESC
LIMIT 10

// 发现社群（使用 Louvain 算法）
CALL algo.louvain.stream('User', 'FOLLOWS')
YIELD nodeId, community
RETURN community, count(*) as size
ORDER BY size DESC

// 查找桥梁节点（连接不同社群）
MATCH (u:User)-[:FOLLOWS]->(friend:User)
WITH u, count(DISTINCT friend.community) as community_count
WHERE community_count > 1
RETURN u.name, community_count
ORDER BY community_count DESC</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="section section-alt">
            <div class="container">
                <h2 class="section-title">
                    <i class="fas fa-book"></i>
                    学习资源
                </h2>
                <div class="section-content">
                    <div class="resources-grid">
                        <a href="https://neo4j.com/docs/" target="_blank" class="resource-card">
                            <div class="resource-icon">
                                <i class="fas fa-file-alt"></i>
                            </div>
                            <h3>官方文档</h3>
                            <p>Neo4j 官方文档，最权威的学习资料</p>
                        </a>
                        <a href="https://neo4j.com/graphacademy/" target="_blank" class="resource-card">
                            <div class="resource-icon">
                                <i class="fas fa-graduation-cap"></i>
                            </div>
                            <h3>GraphAcademy</h3>
                            <p>免费的在线课程和认证培训</p>
                        </a>
                        <a href="https://neo4j.com/sandbox/" target="_blank" class="resource-card">
                            <div class="resource-icon">
                                <i class="fas fa-flask"></i>
                            </div>
                            <h3>Sandbox</h3>
                            <p>在线 Neo4j 实例，无需安装即可体验</p>
                        </a>
                        <a href="https://github.com/neo4j" target="_blank" class="resource-card">
                            <div class="resource-icon">
                                <i class="fab fa-github"></i>
                            </div>
                            <h3>GitHub</h3>
                            <p>开源项目和示例代码</p>
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    

    </body>
</html>